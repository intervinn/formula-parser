import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/chemical-symbols/index.js
var require_chemical_symbols = __commonJS({
  "node_modules/chemical-symbols/index.js"(exports, module) {
    module.exports = [
      "H",
      "He",
      "Li",
      "Be",
      "B",
      "C",
      "N",
      "O",
      "F",
      "Ne",
      "Na",
      "Mg",
      "Al",
      "Si",
      "P",
      "S",
      "Cl",
      "Ar",
      "K",
      "Ca",
      "Sc",
      "Ti",
      "V",
      "Cr",
      "Mn",
      "Fe",
      "Co",
      "Ni",
      "Cu",
      "Zn",
      "Ga",
      "Ge",
      "As",
      "Se",
      "Br",
      "Kr",
      "Rb",
      "Sr",
      "Y",
      "Zr",
      "Nb",
      "Mo",
      "Tc",
      "Ru",
      "Rh",
      "Pd",
      "Ag",
      "Cd",
      "In",
      "Sn",
      "Sb",
      "Te",
      "I",
      "Xe",
      "Cs",
      "Ba",
      "La",
      "Ce",
      "Pr",
      "Nd",
      "Pm",
      "Sm",
      "Eu",
      "Gd",
      "Tb",
      "Dy",
      "Ho",
      "Er",
      "Tm",
      "Yb",
      "Lu",
      "Hf",
      "Ta",
      "W",
      "Re",
      "Os",
      "Ir",
      "Pt",
      "Au",
      "Hg",
      "Tl",
      "Pb",
      "Bi",
      "Po",
      "At",
      "Rn",
      "Fr",
      "Ra",
      "Ac",
      "Th",
      "Pa",
      "U",
      "Np",
      "Pu",
      "Am",
      "Cm",
      "Bk",
      "Cf",
      "Es",
      "Fm",
      "Md",
      "No",
      "Lr",
      "Rf",
      "Db",
      "Sg",
      "Bh",
      "Hs",
      "Mt",
      "Ds",
      "Rg",
      "Cn",
      "Nh",
      "Fl",
      "Mc",
      "Lv",
      "Ts",
      "Og"
    ];
  }
});

// node_modules/lodash.isfinite/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isfinite/index.js"(exports, module) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var nativeIsFinite = root.isFinite;
    function isFinite(value) {
      return typeof value == "number" && nativeIsFinite(value);
    }
    module.exports = isFinite;
  }
});

// node_modules/lodash.indexof/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.indexof/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = indexOf;
  }
});

// node_modules/lodash.forown/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.forown/index.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, typeof iteratee == "function" ? iteratee : identity);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    module.exports = forOwn;
  }
});

// node_modules/chemical-formula/index.js
var require_chemical_formula = __commonJS({
  "node_modules/chemical-formula/index.js"(exports, module) {
    var symbols = require_chemical_symbols();
    var isFinite = require_lodash();
    var indexOf = require_lodash2();
    var forOwn = require_lodash3();
    function strictParseInt(value) {
      if (/^(-|\+)?([0-9]+|Infinity)$/.test(value)) {
        return Number(value);
      }
      return NaN;
    }
    function getAtomicNumber(symbol) {
      var index = indexOf(symbols, symbol);
      return index > -1 ? index + 1 : -1;
    }
    function chemicalFormula(formula) {
      var ret = {};
      var stack;
      var molecule = "";
      var withinParenthesis = false;
      for (var i = 0, length = formula.length; i < length; ) {
        if (formula.charAt(i) === "(") {
          withinParenthesis = true;
          stack = null;
          i++;
          continue;
        } else if (formula.charAt(i) === ")") {
          withinParenthesis = false;
          i++;
          continue;
        }
        var lengthOfSymbol;
        var atomicNumber = getAtomicNumber(formula.substring(i, i + 2));
        if (atomicNumber === -1) {
          atomicNumber = getAtomicNumber(formula.charAt(i));
          lengthOfSymbol = 1;
        } else {
          lengthOfSymbol = 2;
        }
        var mol;
        if (atomicNumber > -1) {
          if (i > 0 && formula.charAt(i - 1) === ")") {
            mol = chemicalFormula(molecule);
            forOwn(mol, function(count, key) {
              if (ret[key]) {
                ret[key] += count;
              } else {
                ret[key] = count;
              }
            });
            molecule = "";
          }
          stack = symbols[atomicNumber - 1];
          if (!withinParenthesis) {
            if (ret[stack]) {
              ret[stack]++;
            } else {
              ret[stack] = 1;
            }
          } else {
            molecule += stack;
          }
        } else {
          var subscript = strictParseInt(formula.substring(i, i + 2));
          if (isFinite(subscript)) {
            if (!stack) {
              throw new Error("Subscript found before element(s)");
            }
            if (!withinParenthesis && molecule !== "") {
              mol = chemicalFormula(molecule);
              forOwn(mol, function(count, key) {
                if (ret[key]) {
                  ret[key] += count * subscript;
                } else {
                  ret[key] = count * subscript;
                }
              });
              molecule = "";
            } else {
              ret[stack] += subscript - 1;
              lengthOfSymbol++;
            }
          } else {
            subscript = strictParseInt(formula.charAt(i));
            if (isFinite(subscript)) {
              if (!stack) {
                throw new Error("Subscript found before element(s)");
              }
              ret[stack] += subscript - 1;
            } else {
              ret[stack]++;
            }
          }
        }
        i += lengthOfSymbol;
      }
      return ret;
    }
    module.exports = chemicalFormula;
  }
});
export default require_chemical_formula();
//# sourceMappingURL=chemical-formula.js.map
